# v8引擎
一个TCP请求能发送几个http请求? 跟协议相关
virtual dom的优势在哪？
https://juejin.im/post/5e7426d15188254967069c00

v8垃圾回收机制

- js是单线程的，请问这个单线程包括setTimeOut promise addEventListener这些吗？
是什么的单线程?
在chrome中会有多个进程，它是一个多进程架构的，所以他很快，每个tab都会来一个新的页面，都是一个新的进程，每个进程中又有子进程GPU，渲染进程 等
渲染进程 input标签(这个input是一个文件类型file)，首先它是DOM树中的一个input元素（一个element）-》加上css中的渲染树，两个结合起来，进行layout布局，位置的计算。
通过与浏览器主进程通信，主进程读取磁盘图片数据返回给渲染进程（说明这个是一个html5中的属性url fileReader对象，可以把本地文件协议file:// 变成一个临时本地浏览器中访问的url协议，使用的就是url对象+fileReader对象，所以要通过浏览器主进程去做，因为他要通过主进程去跟文件系统打交道，我们的渲染进程是没有这个权力的。他是一个子进程，他要告诉整个应用的进程，应用间通信IPC，再把数据返回给渲染进程，渲染进程通过url filereader就能立马在页面上显示出来，然后再上传，这样的上传过程可视化就更好一些，），
渲染进程中的js发起ajax请求是通过浏览器主进程去调用网络进程发起请求还是渲染进程可以直接调用网络进程发送请求？
浏览器接收到消息 应该会通知网络进程 网络进程会和渲染进程建立数据通道传输数据
ajax请求是由js的那个对象提供的？
xmlHttpRequest对象（红宝书）
最开始是 js ie6中 他是以什么什么身份登场的？在其他浏览器之前是叫什么名字？ActiveXObject就想要给插件一样，有了这个浏览器就能通过网络进程去发送请求
浏览器嗅探：
function getHTTPObject() {
    if (typeof XMLHttpRequest == 'undefined') {
        XMLHttpRequest = function () {
            try { return new ActiveXObject('Msxml2.XMLHTTP.6.0');}
                catch (e) {}
            try { return new ActiveXObject('Msxml2.XMLHTTP.3.0');}
                catch (e) {}
            try { return new ActiveXObject('Msxml2.XMLHTTP');}
                catch (e) {}
            return false;
        }
    }
    return new XMLHttpRequest();
}

原文链接：https://blog.csdn.net/LeapMotion1/java/article/details/78216921
浏览器支持ActiveXObject的几个版本的演变
IE6.0后面就变成了xmlhttprequest,所有的浏览器都支持
浏览器嗅探，jQuery把他封装了，所以不用再写上面的，直接$.ajax，jquery主要做的就是屏蔽了兼容性问题，让代码在所有浏览器都支持，省掉了不应该写的代码，让编程focus到业务层。

回到问题
首先什么叫做渲染进程？
一个chrome打开，任务管理器，每个打开的页面都是一个独立的进程，chrome打开进程为什么每个tab新开一个进程？
首先，一个页面打开一个进程，会更快，这个页面就做了这个页面相关的 dom->css->layout->js执行
独立的启用进程做这个事情，在chrome之前，所有的tab都是共用一个渲染进程的，所以当打开的浏览器一多，就会卡，现在每个页面有一个独立的进程，打开就快。这个需求是的那个页面越来越复杂的时候2008年前后 微博 twitter 副应用
还有一点是更安全，chrome中有沙箱的概念，如果用同一个进程打开不同的网页里面有不同的url，就会有安全性问题，比如xxs,如果是多个tab，进程间就做了隔离，会更加安全。

打开的每个tab就是js单线程的数组

js在new对象的时候是单线程的，因为代码从上到下执行
独立于js引擎之外的 xmlhttprequest后面有http进程去发送请求，然后随着状态码改变
渲染进程是可以直接调用网络进程发送请求的，不需要通过浏览器主进程调用网络进程
1. js的单线程是指js代码的运行环境（chrome中是指v8引擎的单线程）,(在chrome中v8引擎开源后有了node),他只负责词法 语法 上下文环境 AST树...编译成二进制流，让他能执行，这个方面上他是单线程的，单线程来自哪里？一个tab启动 新的进程（进程是分配资源的最小单元），因为进程之间切换消耗是很大的 cpu轮循消耗大，所以在启动一个进程后会启动一个主线程，js运行就是依赖这个线程mainThread 

# js内存

1. GUI渲染线程
负责渲染浏览器界面，解析html css(css放头部不会阻塞，因为他来的时候是html已经搞完了之后) 再构建DOM树，render树，布局与绘制
然后底部的js就会执行，执行完了后到空闲状态，
单线程 因为我们的dom结构是显示给用户的，如果是多线程，就可能对同一个DOM元素产生争抢，可能有多个进程对这个DOM进行修改，结果不久可确定，对线程会让简单的web编程变得复杂（前端编程）
2. 事件触发线程
当作事件监听的时候，事件监听进入事件循环队列中event loop 这里面循环检测某个事件有没有执行，先进先出，把执行后的消息交给GUI 交给主线程
事件触发线程不属于渲染线程，它属于浏览器 定时器 事件监听是由浏览器负责的
3. http请求线程
4. 定时器触发 这两个都在浏览器中

js的单线程 = js引擎线程（也就是v8）

# 闭包 引用式赋值 语言的动态性 作用域 隐式类型转换 相结合 他们都是js内存概念
v8中怎么处理内存 处理垃圾回收 一句js代码是怎么执行的
极客时间李兵

1. 小黄书 + 讶语 -》 浏览器底层 联系起来所有考点
js不需要直接去管理内存 c c++需要
js是解释型语言
引用式赋值，词法分析
为什么会产生引用式赋值？
function foo() {
    var a = {name: 'linan'}
    var b = a
    a.name = '临安'
    console.log(a); //'临安'
    console.log(b); //'临安'
}

代码读入到内存中会先打碎程token
存储空间=代码空间+ 栈空间+堆空间
简单数据类型（变量 常量） -》 栈空间
复杂数据 -》 堆空间
栈 是在顶端的后进先出的
堆是什么？
为什么在有栈空间后还要有堆空间

js内存空间 栈空间 堆空间
首先栈是全局作用域，为什么要有一个栈 栈存放变量
代码跟html一样是不好理解的，所以选择数据结构+算法
1. 执行栈  构建作用域
2. 执行 进行变量的查找
栈 可以让不同的作用域入栈 并且顺序执行，从栈顶到
js是一个预编译语言 创建执行上下文 然后按照顺序执行代码 执行栈

为什么要分成两个？
因为js需要有栈这种结构，维护程序执行期间上下文的状态，图如果栈空间大了，所有数据存放在栈空间，会影响上下文血环的效率 作用域查找
所以复杂的数据类型放到堆空间中
栈负责程序流程，堆负责大的数据的存放 代码解析器

从内存维护上看闭包 闭包的内存模型